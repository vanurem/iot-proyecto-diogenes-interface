<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Monitor de Basurero</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/cosmo/bootstrap.min.css">
  <style>
    canvas { margin-top: 20px; }
    #btnConnect { background-color: #28a745; border-color: #28a745; color: #fff; }
    #btnStart { background-color: #007bff; border-color: #007bff; color: #fff; }
    #btnStop { background-color: #ffc107; border-color: #ffc107; color: #212529; }
    #btnLimpiar { background-color: #dc3545; border-color: #dc3545; color: #fff; }
    [onclick="cargarDatosPrueba()"] { background-color: #007bff; border-color: #007bff; color: #fff; }
    .table-scroll {
      max-height: 320px;
      overflow-y: auto;
      display: block;
    }
    .table-scroll table {
      margin-bottom: 0;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-light">
  <div class="container py-4">
    <h2 class="mb-4 text-primary">Datos en tiempo real</h2>
    <div class="mb-3">
      <button id="btnConnect" class="btn btn-success me-2">Conectar</button>
      <button id="btnStart" class="btn btn-primary me-2">Iniciar</button>
      <button id="btnStop" class="btn btn-warning me-2">Detener y Guardar CSV</button>
      <button onclick="cargarDatosPrueba()" class="btn btn-info me-2">Cargar datos de prueba</button>
      <button id="btnLimpiar" class="btn btn-danger">Limpiar</button>
    </div>
    <div id="status" class="alert alert-secondary mb-4">Estado: esperando conexión...</div>
    <div class="row mb-4">
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Promedio Distancia</div>
          <div class="card-body"><p id="kpiDistancia" class="card-text fs-4">0 cm</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Tiempo medio detección</div>
          <div class="card-body"><p id="kpiTiempo" class="card-text fs-4">0 s</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Ciclos completados</div>
          <div class="card-body"><p id="kpiCiclos" class="card-text fs-4">0</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Duración promedio ciclo</div>
          <div class="card-body"><p id="kpiDuracionCiclo" class="card-text fs-4">0 h</p></div>
        </div>
      </div>
    </div>
    <div class="row mb-4">
      <div class="col-md-6">
        <div class="table-responsive table-scroll mb-0">
          <table id="dataTable" class="table table-bordered table-striped mb-0">
            <thead class="table-dark">
              <tr><th>Timestamp</th><th>Distancia (cm)</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="col-md-6 d-flex align-items-center">
        <div class="w-100 bg-white p-3 rounded shadow-sm">
          <canvas id="grafico" width="600" height="300"></canvas>
        </div>
      </div>
    </div>
    <div class="row mb-4">
      <div class="col-12">
        <h4>Historial de ciclos</h4>
        <div class="table-responsive table-scroll mb-0">
          <table id="historialTable" class="table table-bordered table-striped mb-0">
            <thead class="table-dark">
              <tr>
                <th>#</th>
                <th>Fecha inicio</th>
                <th>Fecha fin</th>
                <th>Promedio Distancia (cm)</th>
                <th>Tiempo medio detección (s)</th>
                <th>Duración ciclo (h)</th>
                <th>Muestras</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  <script>
    let port, reader, keepReading = false;
    let lines = [];
    let distanciaAnterior = null, pesoAnterior = null;
    let readableStreamClosed = null;
    let lineReader = null;
    const UMBRAL_CM = 5;
    const DISTANCIA_VACIO = 120;
    const DISTANCIA_LLENO = 5;
    let sumaDistancia = 0, count = 0;
    let muestrasAntesAlarma = 0, totalAlarmas = 0;
    let tiempoUltimaAlarma = null, tiempoTotalAlarma = 0;
    let tiempoUltimaMuestra = null;
    let tiemposEntreAlarmas = [];
    let enAlarma = false;
    const ctx = document.getElementById('grafico').getContext('2d');
    const grafico = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Distancia (cm)', data: [], borderColor: 'blue', fill: false }
        ]
      },
      options: { responsive: true }
    });
    function setStatus(msg) {
      document.getElementById('status').textContent = "Estado: " + msg;
    }
    async function connect() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        setStatus("conectado");
      } catch (e) {
        setStatus("error de conexión: " + e.message);
      }
    }
    async function start() {
      if (!port || !port.readable) {
        setStatus("Primero conecta el dispositivo.");
        return;
      }
      if (lineReader) {
        setStatus("Ya está en lectura.");
        return;
      }
      keepReading = true;
      const decoder = new TextDecoderStream();
      const inputDone = port.readable.pipeTo(decoder.writable);
      const lineStream = decoder.readable
        .pipeThrough(new TransformStream({
          start(controller) { this.chunks = ""; },
          transform(chunk, controller) {
            this.chunks += chunk;
            let lines = this.chunks.split("\n");
            this.chunks = lines.pop();
            for (const line of lines) controller.enqueue(line.trim());
          },
          flush(controller) {
            if (this.chunks) controller.enqueue(this.chunks.trim());
          }
        }));
      lineReader = lineStream.getReader();
      while (keepReading) {
        const { value, done } = await lineReader.read();
        if (done) break;
        if (value) {
          const match = value.match(/Distancia: (\d+) cm/);
          if (match) {
            const distancia = parseInt(match[1]);
            const ts = new Date().toISOString();
            lines.push(`${ts},${distancia}`);
            addRow(ts, distancia);
            distanciaAnterior = distancia;
          }
        }
      }
      lineReader.releaseLock();
      lineReader = null;
    }
    function cargarDatosPrueba() {
      limpiarDatos();
      const datosPrueba = [
        { ts: "2025-11-24T08:00:00Z", distancia: 120 },
        { ts: "2025-11-24T09:00:00Z", distancia: 100 },
        { ts: "2025-11-24T10:00:00Z", distancia: 60 },
        { ts: "2025-11-24T11:00:00Z", distancia: 20 },
        { ts: "2025-11-24T12:00:00Z", distancia: 5 },
        { ts: "2025-11-24T13:00:00Z", distancia: 120 },
        { ts: "2025-11-25T08:00:00Z", distancia: 120 },
        { ts: "2025-11-25T09:00:00Z", distancia: 90 },
        { ts: "2025-11-25T10:00:00Z", distancia: 50 },
        { ts: "2025-11-25T11:00:00Z", distancia: 10 },
        { ts: "2025-11-25T12:00:00Z", distancia: 4 },
        { ts: "2025-11-25T13:00:00Z", distancia: 115 },
        { ts: "2025-11-26T08:00:00Z", distancia: 118 },
        { ts: "2025-11-26T09:00:00Z", distancia: 80 },
        { ts: "2025-11-26T10:00:00Z", distancia: 40 },
        { ts: "2025-11-26T11:00:00Z", distancia: 7 },
        { ts: "2025-11-26T12:00:00Z", distancia: 5 },
        { ts: "2025-11-26T13:00:00Z", distancia: 120 }
      ];
      let sumaDistanciaLocal = 0, countLocal = 0;
      let tiemposEntreAlarmasLocal = [];
      let enAlarmaLocal = false;
      let cicloInicioLocal = null;
      let tiempoUltimaAlarmaLocal = null;
      datosPrueba.forEach((d, idx) => {
        const table = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
        const row = table.insertRow(0);
        row.insertCell(0).textContent = formatearFecha(d.ts);
        row.insertCell(1).textContent = d.distancia;
        grafico.data.labels.push(formatearFecha(d.ts));
        grafico.data.datasets[0].data.push(d.distancia);
        sumaDistanciaLocal += d.distancia;
        countLocal++;
        if (!cicloInicioLocal && d.distancia > UMBRAL_CM) {
          cicloInicioLocal = d.ts;
        }
        if (!enAlarmaLocal && d.distancia <= UMBRAL_CM) {
          enAlarmaLocal = true;
          if (tiempoUltimaAlarmaLocal) {
            const tActual = new Date(d.ts).getTime();
            tiemposEntreAlarmasLocal.push((tActual - tiempoUltimaAlarmaLocal) / 1000);
            tiempoUltimaAlarmaLocal = tActual;
          } else {
            tiempoUltimaAlarmaLocal = new Date(d.ts).getTime();
          }
        }
        if (enAlarmaLocal && d.distancia > UMBRAL_CM) {
          enAlarmaLocal = false;
          let duracionHoras = 0;
          if (cicloInicioLocal) {
            const inicio = new Date(cicloInicioLocal).getTime();
            const fin = new Date(d.ts).getTime();
            duracionHoras = (fin - inicio) / (1000 * 60 * 60);
          }
          historialCiclos.push({
            inicio: cicloInicioLocal,
            fin: d.ts,
            promedioDistancia: countLocal ? (sumaDistanciaLocal / countLocal).toFixed(1) : 0,
            tiempoMedio: tiemposEntreAlarmasLocal.length > 0
              ? (tiemposEntreAlarmasLocal.reduce((a, b) => a + b, 0) / tiemposEntreAlarmasLocal.length).toFixed(1)
              : 0,
            duracionHoras: duracionHoras.toFixed(2),
            muestras: countLocal
          });
          sumaDistanciaLocal = 0;
          countLocal = 0;
          tiemposEntreAlarmasLocal = [];
          cicloInicioLocal = null;
          tiempoUltimaAlarmaLocal = null;
          table.innerHTML = "";
          grafico.data.labels = [];
          grafico.data.datasets[0].data = [];
          grafico.update();
        }
      });
      actualizarHistorial();
      actualizarKPIs();
      setStatus("Datos de prueba cargados");
    }
    function formatearFecha(ts) {
      const fecha = new Date(ts);
      const dia = String(fecha.getDate()).padStart(2, '0');
      const mes = String(fecha.getMonth() + 1).padStart(2, '0');
      const anio = fecha.getFullYear();
      const hora = String(fecha.getHours()).padStart(2, '0');
      const min = String(fecha.getMinutes()).padStart(2, '0');
      const seg = String(fecha.getSeconds()).padStart(2, '0');
      return `${dia}/${mes}/${anio} ${hora}:${min}:${seg}`;
    }
    let historialCiclos = [];
    let cicloInicio = null;
    let duracionesCiclos = [];
    function addRow(ts, distancia) {
      if (distanciaAnterior !== null && distancia === distanciaAnterior) {
        return;
      }
      distanciaAnterior = distancia;
      const table = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
      const row = table.insertRow(0);
      row.insertCell(0).textContent = formatearFecha(ts);
      row.insertCell(1).textContent = distancia;
      grafico.data.labels.push(formatearFecha(ts));
      grafico.data.datasets[0].data.push(distancia);
      grafico.update();
      sumaDistancia += distancia;
      count++;
      if (!enAlarma && distancia > UMBRAL_CM) {
        muestrasAntesAlarma++;
      }
      if (!enAlarma && distancia <= UMBRAL_CM) {
        enAlarma = true;
        totalAlarmas++;
        if (tiempoUltimaAlarma) {
          const tActual = new Date(ts).getTime();
          tiemposEntreAlarmas.push((tActual - tiempoUltimaAlarma) / 1000);
          tiempoUltimaAlarma = tActual;
        } else {
          tiempoUltimaAlarma = new Date(ts).getTime();
        }
        tiempoUltimaMuestra = new Date(ts).getTime();
      }
      if (!cicloInicio && distancia > UMBRAL_CM) {
        cicloInicio = ts;
      }
      if (enAlarma && distancia > UMBRAL_CM) {
        enAlarma = false;
        let duracionHoras = 0;
        if (cicloInicio) {
          const inicio = new Date(cicloInicio).getTime();
          const fin = new Date(ts).getTime();
          duracionHoras = (fin - inicio) / (1000 * 60 * 60);
          duracionesCiclos.push(duracionHoras);
        }
        historialCiclos.push({
          inicio: cicloInicio,
          fin: ts,
          promedioDistancia: count ? (sumaDistancia / count).toFixed(1) : 0,
          tiempoMedio: tiemposEntreAlarmas.length > 0
            ? (tiemposEntreAlarmas.reduce((a, b) => a + b, 0) / tiemposEntreAlarmas.length).toFixed(1)
            : 0,
          duracionHoras: duracionHoras.toFixed(2),
          muestras: count
        });
        actualizarHistorial();
        sumaDistancia = 0;
        count = 0;
        tiemposEntreAlarmas = [];
        muestrasAntesAlarma = 0;
        totalAlarmas = 0;
        tiempoUltimaAlarma = null;
        tiempoUltimaMuestra = null;
        cicloInicio = null;
        const tableBody = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
        tableBody.innerHTML = "";
        grafico.data.labels = [];
        grafico.data.datasets[0].data = [];
        grafico.update();
      }
      actualizarKPIs();
    }
    function actualizarKPIs() {
      let promedioDistancia = historialCiclos.length > 0
        ? (historialCiclos.reduce((a, b) => a + parseFloat(b.promedioDistancia), 0) / historialCiclos.length)
        : 0;
      document.getElementById('kpiDistancia').textContent = promedioDistancia.toFixed(1) + " cm";
      let tiempoMedioGlobal = historialCiclos.length > 0
        ? (historialCiclos.reduce((a, b) => a + parseFloat(b.tiempoMedio), 0) / historialCiclos.length)
        : 0;
      document.getElementById('kpiTiempo').textContent = tiempoMedioGlobal.toFixed(1) + " s";
      document.getElementById('kpiCiclos').textContent = historialCiclos.length;
      let duracionPromedio = historialCiclos.length > 0
        ? (historialCiclos.reduce((a, b) => a + parseFloat(b.duracionHoras), 0) / historialCiclos.length)
        : 0;
      document.getElementById('kpiDuracionCiclo').textContent = duracionPromedio.toFixed(2) + " h";
    }
    async function stopAndSave() {
      keepReading = false;
      try { 
        if (lineReader) { 
          await lineReader.cancel(); 
          lineReader.releaseLock(); 
          lineReader = null;
        }
        if (readableStreamClosed) {
          await readableStreamClosed.catch(() => {});
          readableStreamClosed = null;
        }
      } catch {}
      try { if (port) { await port.close(); } } catch {}
      setStatus("desconectado");
      const header = "timestamp,distancia_cm\n";
      const csv = header + lines.join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `mediciones_${new Date().toISOString()}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
    function limpiarDatos() {
      sumaDistancia = 0;
      count = 0;
      muestrasAntesAlarma = 0;
      totalAlarmas = 0;
      tiempoUltimaAlarma = null;
      tiempoTotalAlarma = 0;
      tiempoUltimaMuestra = null;
      tiemposEntreAlarmas = [];
      enAlarma = false;
      historialCiclos = [];
      cicloInicio = null;
      duracionesCiclos = [];
      lines = [];
      document.getElementById('dataTable').getElementsByTagName('tbody')[0].innerHTML = "";
      grafico.data.labels = [];
      grafico.data.datasets[0].data = [];
      grafico.update();
      actualizarHistorial();
      actualizarKPIs();
      setStatus("Datos limpiados");
    }
    function actualizarHistorial() {
      const table = document.getElementById('historialTable').getElementsByTagName('tbody')[0];
      table.innerHTML = "";
      historialCiclos.forEach((ciclo, idx) => {
        const row = table.insertRow();
        row.insertCell(0).textContent = idx + 1;
        row.insertCell(1).textContent = formatearFecha(ciclo.inicio);
        row.insertCell(2).textContent = formatearFecha(ciclo.fin);
        row.insertCell(3).textContent = ciclo.promedioDistancia;
        row.insertCell(4).textContent = ciclo.tiempoMedio;
        row.insertCell(5).textContent = ciclo.duracionHoras + " h";
        row.insertCell(6).textContent = ciclo.muestras;
      });
    }
    document.getElementById('btnConnect').onclick = connect;
    document.getElementById('btnStart').onclick = start;
    document.getElementById('btnStop').onclick = stopAndSave;
    document.getElementById('btnLimpiar').onclick = limpiarDatos;
    if (!("serial" in navigator)) {
      setStatus("tu navegador no soporta Web Serial (usa Chrome/Edge de escritorio).");
    }
  </script>
</body>
</html>
