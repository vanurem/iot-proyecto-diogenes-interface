<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Monitor de Basurero</title>
  <!-- Bootstrap Cosmo Theme (Bootswatch) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/cosmo/bootstrap.min.css">
  <style>
    canvas { margin-top: 20px; }

    /* Solo cambia los colores de los botones */
    #btnConnect { background-color: #28a745; border-color: #28a745; color: #fff; }   /* Verde */
    #btnStart { background-color: #007bff; border-color: #007bff; color: #fff; }    /* Azul */
    #btnStop { background-color: #ffc107; border-color: #ffc107; color: #212529; }  /* Amarillo */
    #btnLimpiar { background-color: #dc3545; border-color: #dc3545; color: #fff; }  /* Rojo */
    [onclick="cargarDatosPrueba()"] { background-color: #007bff; border-color: #007bff; color: #fff; } /* Azul */

    .table-scroll {
      max-height: 320px;
      overflow-y: auto;
      display: block;
    }
    .table-scroll table {
      margin-bottom: 0;
    }
  </style>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-light">
  <div class="container py-4">
    <h2 class="mb-4 text-primary">Datos en tiempo real</h2>
    <div class="mb-3">
      <button id="btnConnect" class="btn btn-success me-2">Conectar</button>
      <button id="btnStart" class="btn btn-primary me-2">Iniciar</button>
      <button id="btnStop" class="btn btn-warning me-2">Detener y Guardar CSV</button>
      <button onclick="cargarDatosPrueba()" class="btn btn-info me-2">Cargar datos de prueba</button>
      <button id="btnLimpiar" class="btn btn-danger">Limpiar</button>
    </div>
    <div id="status" class="alert alert-secondary mb-4">Estado: esperando conexión...</div>

    <!-- KPIs -->
    <div class="row mb-4">
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Promedio Distancia</div>
          <div class="card-body"><p id="kpiDistancia" class="card-text fs-4">0 cm</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Promedio Peso</div>
          <div class="card-body"><p id="kpiPeso" class="card-text fs-4">0 %</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Nivel antes de alarma</div>
          <div class="card-body"><p id="kpiAlarma" class="card-text fs-4">0 %</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Tiempo medio detección</div>
          <div class="card-body"><p id="kpiTiempo" class="card-text fs-4">0 s</p></div>
        </div>
      </div>
    </div>

    <!-- Tabla y Gráfico -->
    <div class="row mb-4">
      <div class="col-md-6">
        <div class="table-responsive table-scroll mb-0">
          <table id="dataTable" class="table table-bordered table-striped mb-0">
            <thead class="table-dark">
              <tr><th>Timestamp</th><th>Distancia (cm)</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="col-md-6 d-flex align-items-center">
        <div class="w-100 bg-white p-3 rounded shadow-sm">
          <canvas id="grafico" width="600" height="300"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    let port, reader, keepReading = false;
    let lines = [];
    let distanciaAnterior = null, pesoAnterior = null;
    let readableStreamClosed = null; // <--- agrega esto
    let lineReader = null;           // <--- agrega esto

    const UMBRAL_CM = 5; // Umbral de alarma (lleno)
    const DISTANCIA_VACIO = 120; // Ajusta según tu basurero
    const DISTANCIA_LLENO = 5;   // Igual al umbral

    // KPIs acumuladores
    let sumaDistancia = 0, count = 0;
    let muestrasAntesAlarma = 0, totalAlarmas = 0;
    let tiempoUltimaAlarma = null, tiempoTotalAlarma = 0;
    let tiempoUltimaMuestra = null;
    let tiemposEntreAlarmas = [];
    let enAlarma = false;

    // Chart.js setup
    const ctx = document.getElementById('grafico').getContext('2d');
    const grafico = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Distancia (cm)', data: [], borderColor: 'blue', fill: false }
        ]
      },
      options: { responsive: true }
    });

    function setStatus(msg) {
      document.getElementById('status').textContent = "Estado: " + msg;
    }

    async function connect() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        setStatus("conectado");
      } catch (e) {
        setStatus("error de conexión: " + e.message);
      }
    }

    async function start() {
      if (!port || !port.readable) {
        setStatus("Primero conecta el dispositivo.");
        return;
      }
      if (lineReader) {
        setStatus("Ya está en lectura.");
        return;
      }
      keepReading = true;
      const decoder = new TextDecoderStream();
      const inputDone = port.readable.pipeTo(decoder.writable);

      // TransformStream para dividir por líneas
      const lineStream = decoder.readable
        .pipeThrough(new TransformStream({
          start(controller) { this.chunks = ""; },
          transform(chunk, controller) {
            this.chunks += chunk;
            let lines = this.chunks.split("\n");
            this.chunks = lines.pop();
            for (const line of lines) controller.enqueue(line.trim());
          },
          flush(controller) {
            if (this.chunks) controller.enqueue(this.chunks.trim());
          }
        }));

      lineReader = lineStream.getReader();

      while (keepReading) {
        const { value, done } = await lineReader.read();
        if (done) break;
        if (value) {
          // Solo distancia: "Distancia: 123 cm"
          const match = value.match(/Distancia: (\d+) cm/);
          if (match) {
            const distancia = parseInt(match[1]);
            const ts = new Date().toISOString();
            lines.push(`${ts},${distancia}`);
            addRow(ts, distancia);
            distanciaAnterior = distancia;
          }
        }
      }
      lineReader.releaseLock();
      lineReader = null;
    }

    function cargarDatosPrueba() {
      const datosPrueba = [
        { ts: "2025-11-18T09:00:00Z", distancia: 120, peso: 40 },
        { ts: "2025-11-18T09:01:00Z", distancia: 118, peso: 45 },
        { ts: "2025-11-18T09:02:00Z", distancia: 115, peso: 50 },
        { ts: "2025-11-18T09:03:00Z", distancia: 110, peso: 80 },
        { ts: "2025-11-18T09:04:00Z", distancia: 108, peso: 85 },
        { ts: "2025-11-18T09:05:00Z", distancia: 105, peso: 90 }
      ];

      datosPrueba.forEach(d => {
        lines.push(`${d.ts},${d.distancia},${d.peso}`);
        addRow(d.ts, d.distancia, d.peso);
      });

      setStatus("Datos de prueba cargados");
    }

    function formatearFecha(ts) {
      const fecha = new Date(ts);
      const dia = String(fecha.getDate()).padStart(2, '0');
      const mes = String(fecha.getMonth() + 1).padStart(2, '0');
      const anio = fecha.getFullYear();
      const hora = String(fecha.getHours()).padStart(2, '0');
      const min = String(fecha.getMinutes()).padStart(2, '0');
      const seg = String(fecha.getSeconds()).padStart(2, '0');
      return `${dia}/${mes}/${anio} ${hora}:${min}:${seg}`;
    }

    function addRow(ts, distancia) {
      // Tabla (insertar arriba)
      const table = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
      const row = table.insertRow(0);
      row.insertCell(0).textContent = formatearFecha(ts);
      row.insertCell(1).textContent = distancia;

      // Gráfico (usa fecha legible)
      grafico.data.labels.push(formatearFecha(ts)); // <-- aquí el cambio
      grafico.data.datasets[0].data.push(distancia);
      grafico.update();

      // KPIs
      sumaDistancia += distancia;
      count++;

      // Nivel antes de alarma
      if (!enAlarma && distancia > UMBRAL_CM) {
        muestrasAntesAlarma++;
      }

      // Detección de cruce de umbral (evento de alarma)
      if (!enAlarma && distancia <= UMBRAL_CM) {
        enAlarma = true;
        totalAlarmas++;
        if (tiempoUltimaAlarma) {
          const tActual = new Date(ts).getTime();
          tiemposEntreAlarmas.push((tActual - tiempoUltimaAlarma) / 1000);
          tiempoUltimaAlarma = tActual;
        } else {
          tiempoUltimaAlarma = new Date(ts).getTime();
        }
        tiempoUltimaMuestra = new Date(ts).getTime();
      }

      // Salida de alarma
      if (enAlarma && distancia > UMBRAL_CM) {
        enAlarma = false;
        const tAhora = new Date(ts).getTime();
        tiempoTotalAlarma += (tAhora - tiempoUltimaMuestra) / 1000;
        tiempoUltimaMuestra = null;
      }

      if (enAlarma) {
        tiempoUltimaMuestra = new Date(ts).getTime();
      }

      actualizarKPIs();
    }

    function autoGuardarYLimpiar() {
      // Guardar CSV automáticamente
      const header = "timestamp,distancia_cm\n";
      const csv = header + lines.join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `mediciones_${new Date().toISOString()}.csv`;
      a.click();
      URL.revokeObjectURL(url);

      // Limpiar datos
      lines = [];
      sumaDistancia = 0; sumaPeso = 0; count = 0;
      sumaTiempoDeteccion = 0; eventosDeteccion = 0;
      pesosAntesAlarma = [];
      ultimoCambio = null;

      // Limpiar tabla
      const tableBody = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
      tableBody.innerHTML = "";

      // Limpiar gráfico
      grafico.data.labels = [];
      grafico.data.datasets[0].data = [];
      grafico.update();

      // Reset KPIs
      actualizarKPIs();

      setStatus("Autoguardado realizado y datos reiniciados");
    }

    function limpiarDatos() {
      if (!confirm("¿Seguro que deseas limpiar todos los datos? Esta acción no se puede deshacer.")) {
        setStatus("Limpieza cancelada");
        return;
      }
      lines = [];
      sumaDistancia = 0; sumaPeso = 0; count = 0;
      sumaTiempoDeteccion = 0; eventosDeteccion = 0;
      pesosAntesAlarma = [];
      ultimoCambio = null;

      // Limpiar tabla
      const tableBody = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
      tableBody.innerHTML = "";

      // Limpiar gráfico
      grafico.data.labels = [];
      grafico.data.datasets[0].data = [];
      grafico.data.datasets[1].data = [];
      grafico.update();

      // Reset KPIs
      actualizarKPIs();

      setStatus("Datos limpiados");
    }

    function actualizarKPIs() {
      // Promedio distancia
      document.getElementById('kpiDistancia').textContent = (sumaDistancia / count).toFixed(1) + " cm";

      // Nivel antes de alarma (% muestras antes de la primera alarma)
      let nivelAlarma = totalAlarmas > 0 ? (muestrasAntesAlarma / count) * 100 : 100;
      document.getElementById('kpiAlarma').textContent = nivelAlarma.toFixed(1) + " %";

      // Tiempo medio detección (segundos entre llenados)
      let tiempoMedio = tiemposEntreAlarmas.length > 0
        ? (tiemposEntreAlarmas.reduce((a, b) => a + b, 0) / tiemposEntreAlarmas.length)
        : 0;
      document.getElementById('kpiTiempo').textContent = tiempoMedio.toFixed(1) + " s";
    }

    
    async function stopAndSave() {
      keepReading = false;
      try { 
        if (lineReader) { 
          await lineReader.cancel(); 
          lineReader.releaseLock(); 
          lineReader = null;
        }
        if (readableStreamClosed) {
          await readableStreamClosed.catch(() => {});
          readableStreamClosed = null;
        }
      } catch {}
      try { if (port) { await port.close(); } } catch {}
      setStatus("desconectado");

      const header = "timestamp,distancia_cm\n";
      const csv = header + lines.join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `mediciones_${new Date().toISOString()}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById('btnConnect').onclick = connect;
    document.getElementById('btnStart').onclick = start;
    document.getElementById('btnStop').onclick = stopAndSave;
    document.getElementById('btnLimpiar').onclick = limpiarDatos;

    if (!("serial" in navigator)) {
      setStatus("tu navegador no soporta Web Serial (usa Chrome/Edge de escritorio).");
    }
  </script>
</body>
</html>
